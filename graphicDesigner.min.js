/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

	// promisous dependency
	window.setImmediate = window.setTimeout;
	
	var graphicDesigner = __webpack_require__(/*! ./core */ 1);
	
	graphicDesigner.plugins.imageUpload = __webpack_require__(/*! ./plugins/imageUpload */ 2);
	graphicDesigner.plugins.cache = __webpack_require__(/*! ./plugins/cache */ 3);
	graphicDesigner.plugins.deleteButton = __webpack_require__(/*! ./plugins/deleteButton */ 4);
	graphicDesigner.plugins.zIndexUpdate = __webpack_require__(/*! ./plugins/zIndexUpdate */ 5);
	graphicDesigner.plugins.backgroundColorPicker = __webpack_require__(/*! ./plugins/backgroundColorPicker */ 14);
	
	
	window.graphicDesigner = graphicDesigner;


/***/ },
/* 1 */
/*!***********************!*\
  !*** ./core/index.js ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	var eventEmitter = __webpack_require__(/*! ./eventEmitter */ 7);
	var svgElement = __webpack_require__(/*! ./svgElement */ 8);
	var select = __webpack_require__(/*! ./select */ 9);
	var move = __webpack_require__(/*! ./move */ 10);
	var _ = __webpack_require__(/*! ./utils */ 6);
	
	
	function graphicDesigner(options) {
	
	    var app = {};
	
	    app.config = _.defaults(options || {}, defaults);
	
	    app.container = document.querySelector(app.config.element);
	
	
	    // plugin activation shortcuts
	    Object.keys(graphicDesigner.plugins).forEach(function(plugin) {
	        app[plugin] = function(options) {
	            graphicDesigner.plugins[plugin](app, options);
	            return app;
	        };
	    });
	
	
	    app.setSize = function(width, height) {
	        if (app.config.unit === 'mm') {
	            width  = mmToInch(width);
	            height = mmToInch(height);
	        }
	        if (app.config.unit !== 'pixel') {
	            width  = width  * app.config.dpi;
	            height = height * app.config.dpi;
	        }
	        app.svg.setAttribute('width' , Math.round(width  * app.config.scaleFactor));
	        app.svg.setAttribute('height', Math.round(height * app.config.scaleFactor));
	    };
	
	
	    app.ready = function() {
	        app.emit('ready');
	    };
	
	
	    eventEmitter(app);
	    svgElement(app);
	    select(app);
	    move(app);
	
	
	    return app;
	}
	
	graphicDesigner.plugins = {};
	
	var defaults = {
	    unit: 'pixel',
	    dpi: 300,
	    width: 500,
	    height: 500,
	    scaleFactor: 1,
	    selectBodyClass: 'item-selected',
	    itemClass: 'item',
	    itemSelectClass: 'selected',
	    itemDragClass: 'dragging'
	};
	
	
	
	function mmToInch(mm) {
	    return Math.round(mm * 3.937) / 100;
	}
	
	
	
	module.exports = graphicDesigner;


/***/ },
/* 2 */
/*!********************************!*\
  !*** ./plugins/imageUpload.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var Promise = __webpack_require__(/*! promiscuous */ 13);
	var readImage = __webpack_require__(/*! ./utils/readImage */ 11);
	var _ = __webpack_require__(/*! ../core/utils */ 6);
	
	
	module.exports = function(app, options) {
	
	    if (!options) options = {};
	
	    // chrome behaves weird and fires drag enter/leave events randomly
	    var throttle;
	
	    var input = document.createElement('input');
	    input.type = 'file';
	    input.accept = 'image/*';
	
	
	    function triggerFileInput() {
	        var event = document.createEvent('HTMLEvents');
	        event.initEvent('click', true, false);
	        input.dispatchEvent(event);
	    }
	    document.querySelector(options.element).addEventListener('click', triggerFileInput);
	
	    input.addEventListener('change', function() {
	        if (input.files.length !== 1) return;
	        readImage(input.files[0]).then(scale).then(center).then(create);
	    });
	
	
	    function dragIn(e) {
	        e.preventDefault();
	        if (throttle) clearTimeout(throttle);
	        dropClass(true);
	    }
	    function dragOut() {
	        if (throttle) clearTimeout(throttle);
	        throttle = setTimeout(function() {
	            dropClass(false);
	        }, 300);
	    }
	    document.addEventListener('dragenter', dragIn);
	    document.addEventListener('dragover', dragIn);
	    document.addEventListener('dragleave', dragOut);
	
	    document.addEventListener('drop', function(e) {
	        e.preventDefault();
	        dropClass(false);
	        // TODO: warn on big image size
	        uploadDropped(e).then(scale).then(placeAt(e)).then(create);
	    });
	
	    function dropClass(active) {
	        if (options.dropBodyClass) {
	            document.body.classList[active ? 'add' : 'remove'](options.dropBodyClass);
	        }
	    }
	
	    function uploadDropped(e) {
	        if (e.dataTransfer.files.length > 1) return Promise.reject();
	        return readImage(e.dataTransfer.files[0]);
	    }
	
	    // scale to fit in screen
	    function scale(image) {
	        // NOTE: maybe there is a smarter way for this calcualtion ..
	        var rect = app.svg.getBoundingClientRect();
	        var factor = Math.min(rect.width / image.width, rect.height / image.height, 1);
	        image.width = Math.round(factor * image.width);
	        image.height = Math.round(factor * image.height);
	        return image;
	    }
	
	    function center(image) {
	        var rect = app.svg.getBoundingClientRect();
	        image.x = Math.round(0.5 * (rect.width - image.width ));
	        image.y = Math.round(0.5 * (rect.height - image.height ));
	        return image;
	    }
	
	    function create(image) {
	        var el = _.createSvg('image');
	        el.setAttribute('height', image.height);
	        el.setAttribute('width', image.width);
	        el.setAttribute('class', app.config.itemClass);
	        el.setAttributeNS('http://www.w3.org/1999/xlink','href', image.url);
	
	        _.translateSvg(el, image.x, image.y);
	
	        app.svg.appendChild(el);
	        app.emit('element:create', el);
	    }
	
	    function placeAt(event) {
	        if (event.target !== app.svg) {
	            return center;
	        }
	        return function(image) {
	            var rect = app.svg.getBoundingClientRect();
	            var top  = rect.top  + document.body.scrollTop;
	            var left = rect.left + document.body.scrollLeft;
	
	            image.x = Math.round(event.pageX - left - 0.5 * image.width);
	            image.y = Math.round(event.pageY - top  - 0.5 * image.height);
	
	            return image;
	        };
	    }
	
	};


/***/ },
/* 3 */
/*!**************************!*\
  !*** ./plugins/cache.js ***!
  \**************************/
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(/*! ../core/utils */ 6);
	
	
	module.exports = function(app, options) {
	
	    options = _.defaults(options || {}, {
	        storageKey: 'graphicDesignerGraphic'
	    });
	
	
	    app.on('element', updateCache);
	    app.on('background', updateCache);
	
	
	    function loadFromCache() {
	        var backup = localStorage.getItem(options.storageKey);
	        if (!backup) return;
	        app.container.innerHTML = backup;
	        app.svg = app.container.querySelector('svg');
	        app.emit('svg:load');
	    }
	
	    loadFromCache();
	
	
	    function updateCache() {
	        localStorage.setItem(options.storageKey, app.container.innerHTML);
	        app.emit('cache:update');
	    }
	
	};


/***/ },
/* 4 */
/*!*********************************!*\
  !*** ./plugins/deleteButton.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(app, options) {
	
	    var button = document.querySelector(options.element);
	
	
	    app.on('element:select', enableDelete);
	
	
	
	    function enableDelete(el) {
	        button.classList.remove('hide');
	        button.addEventListener('click', deleteElement);
	        app.on('element:unselect', disableDelete);
	
	        function deleteElement() {
	            if (!window.confirm('Soll das ausgewählte Element echt gelöscht werden?')) return;
	            el.parentNode.removeChild(el);
	            button.classList.add('hide');
	            button.removeEventListener('click', deleteElement);
	            app
	                .off('element:unselect', disableDelete)
	                .emit('element:delete', el);
	        }
	
	        function disableDelete() {
	            app.off('element:unselect', disableDelete);
	
	            button.classList.add('hide');
	            button.removeEventListener('click', deleteElement);
	        }
	
	    }
	
	};


/***/ },
/* 5 */
/*!*********************************!*\
  !*** ./plugins/zIndexUpdate.js ***!
  \*********************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(app, options) {
	
	
	    var back  = options.toBack && document.querySelector(options.toBack);
	    var front = options.toFront && document.querySelector(options.toFront);
	
	
	    app.on('element:select', enableZindex);
	
	
	
	    function enableZindex(el) {
	        var prev, next;
	
	        function init() {
	            app.on('element:unselect', disableZindex);
	
	            if (back) back.addEventListener('click', moveToBack);
	            if (front) front.addEventListener('click', moveToFront);
	            setRefs();
	            if (back)  check(back, prev);
	            if (front) check(front, next);
	        }
	
	        function setRefs() {
	            prev = el.previousElementSibling;
	            next = el.nextElementSibling;
	        }
	
	        function check(button, neighbor) {
	            if (!neighbor || !neighbor.classList.contains(app.config.itemClass)) {
	                button.disabled = true;
	            }
	        }
	
	        function moveToBack() {
	            app.svg.insertBefore(el, prev);
	            setRefs();
	            check(back, prev);
	            if (front) front.disabled = false;
	            app.emit('element:change:z-index', el);
	        }
	
	        function moveToFront() {
	            app.svg.insertBefore(el, next.nextElementSibling);
	            setRefs();
	            check(front, next);
	            if (back) back.disabled = false;
	            app.emit('element:change:z-index', el);
	        }
	
	        function disableZindex() {
	            app.off('element:unselect', disableZindex);
	
	            if (back)  disable(back, moveToBack);
	            if (front) disable(front, moveToFront);
	        }
	
	        init();
	    }
	
	
	    function disable(button, handler) {
	        button.disabled = false;
	        button.removeEventListener('click', handler);
	    }
	
	};


/***/ },
/* 6 */
/*!***********************!*\
  !*** ./core/utils.js ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	// TODO: stolen from lodash
	
	var utils = {};
	
	/** Used to determine if values are of the language type Object */
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	
	/**
	 * Assigns own enumerable properties of source object(s) to the destination
	 * object for all destination properties that resolve to `undefined`. Once a
	 * property is set, additional defaults of the same property will be ignored.
	 *
	 * @static
	 * @memberOf _
	 * @type Function
	 * @category Objects
	 * @param {Object} object The destination object.
	 * @param {...Object} [source] The source objects.
	 * @param- {Object} [guard] Allows working with `_.reduce` without using its
	 *  `key` and `object` arguments as sources.
	 * @returns {Object} Returns the destination object.
	 * @example
	 *
	 * var object = { 'name': 'barney' };
	 * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
	 * // => { 'name': 'barney', 'employer': 'slate' }
	 */
	utils.defaults = function(object, source, guard) {
	  var index, iterable = object, result = iterable;
	  if (!iterable) return result;
	  var args = arguments,
	      argsIndex = 0,
	      argsLength = typeof guard == 'number' ? 2 : args.length;
	  while (++argsIndex < argsLength) {
	    iterable = args[argsIndex];
	    if (iterable && objectTypes[typeof iterable]) {
	    var ownIndex = -1,
	        ownProps = objectTypes[typeof iterable] && Object.keys(iterable),
	        length = ownProps ? ownProps.length : 0;
	
	    while (++ownIndex < length) {
	      index = ownProps[ownIndex];
	      if (typeof result[index] == 'undefined') result[index] = iterable[index];
	    }
	    }
	  }
	  return result;
	};
	
	
	
	utils.createSvg = function(tag) {
	    return document.createElementNS('http://www.w3.org/2000/svg', tag);
	};
	
	
	
	utils.translateSvg = function(el) {
	    var values = Array.prototype.slice.call(arguments, 1);
	    if (values.length) return setProp(el, 'translate', values);
	
	    var prop = getProp(el, 'translate');
	    if (!prop) return { x: 0, y: 0 };
	    return { x: prop[0], y: prop[prop.length-1] };
	};
	
	
	function setProp(el, prop, values) {
	    var old = el.getAttribute('transform');
	    var attr;
	    if (!old) {
	        attr = propStr(prop, values);
	    } else if (!old.match(prop)) {
	        attr = old + ' ' + propStr(prop, values);
	    } else {
	        attr = old.replace( new RegExp(prop+'\\((.+?)\\)'), propStr(prop, values) );
	    }
	    return el.setAttribute('transform', attr);
	}
	
	function getProp(el, prop) {
	    var attr = el.getAttribute('transform');
	    if (!attr) return;
	    var raw = attr.match(prop + '\\((.+?)\\)');
	    if (!raw) return;
	    return raw[1].trim().split(' ').map(function(val) {
	        return parseInt(val, 10);
	    });
	}
	
	
	function propStr(prop, values) {
	    return prop+'('+values.join(' ')+')';
	}
	
	
	
	utils.animation = function() {
	
	    var ani;
	
	    return function(fn) {
	        if (ani) cancelAnimationFrame(ani);
	        ani = requestAnimationFrame(fn);
	    };
	
	};
	
	
	
	utils.isMobile = function() {
	    return /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(navigator.userAgent.toLowerCase());
	};
	
	utils.pageX = function(e) {
	    return utils.isMobile() ? e.originalEvent.touches[0].pageX : e.pageX;
	};
	
	utils.pageY = function(e) {
	    return utils.isMobile() ? e.originalEvent.touches[0].pageY : e.pageY;
	};
	
	utils.onMove = function() {
	  return utils.isMobile() ? 'touchmove' : 'mousemove';
	};
	
	utils.onDown = function() {
	  return utils.isMobile() ? 'touchstart' : 'mousedown';
	};
	
	utils.onUp = function() {
	  return utils.isMobile() ? 'touchend' : 'mouseup';
	};
	
	
	
	module.exports = utils;


/***/ },
/* 7 */
/*!******************************!*\
  !*** ./core/eventEmitter.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(obj) {
	
	    var events = {};
	    var slice = [].slice;
	
	    obj.on = function(event, handler) {
	        (events[event] = events[event] || []).push(handler);
	        return obj;
	    };
	
	
	    obj.emit = function(event) {
	        var i, handler;
	        var args = slice.call(arguments, 1);
	        var handlers = [];
	
	        // emit sub:events
	        var parts = event.split(':');
	        for (i = 1; i <= parts.length; i++) {
	            var subHandlers = events[parts.slice(0, i).join(':')];
	            if (subHandlers) handlers = handlers.concat(subHandlers);
	        }
	
	        // NOTE: doesn't log names for once listeners
	        // DEBUG
	        console.log('EVENT: ', event, ' => ',
	            handlers.map(function(f) {
	                return f.name;
	            }).join(', ') || 'nothing to do ...'
	        );
	
	        for (i = 0, handler; (handler = handlers[i]); ++i) {
	            handler.apply(null, args);
	        }
	
	        return obj;
	    };
	
	
	    // remove specific handler or remove all handlers
	    obj.off = function(event, handler) {
	        if (handler) {
	            var handlers = events[event];
	            var i = handlers.indexOf(handler);
	            if (i >= 0) handlers.splice(i, 1);
	        } else {
	            events[event] = [];
	        }
	
	        return obj;
	    };
	
	
	    return obj;
	};


/***/ },
/* 8 */
/*!****************************!*\
  !*** ./core/svgElement.js ***!
  \****************************/
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(/*! ./utils */ 6);
	
	module.exports = function(app) {
	
	    var svg = _.createSvg('svg');
	
	    app.container.innerHTML = ''; // empty first
	    app.container.appendChild(svg);
	
	    app.svg = svg;
	
	    app.setSize(app.config.width, app.config.height);
	
	
	    app.emit('svg:load');
	
	};


/***/ },
/* 9 */
/*!************************!*\
  !*** ./core/select.js ***!
  \************************/
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(/*! ./utils */ 6);
	
	
	module.exports = function(app) {
	
	    app
	        .on('element:create', select)
	        .on('element:delete', clean)
	        .on('render', clean)
	        .on('svg:load', triggerSelect)
	        .on('ready', triggerSelect);
	
	
	    app.container.addEventListener(_.onDown(), selectTarget);
	
	
	    function triggerSelect() {
	        var el = getSelected();
	        if (!el) return;
	        bodyClass(true);
	        app.emit('element:select', el);
	    }
	
	    function selectTarget(e) {
	        if (e.target === app.svg) {
	            clean();
	            return;
	        }
	        var notElement = !e.target.classList.contains(app.config.itemClass);
	        if (notElement) return;
	        e.stopPropagation();
	        var notSelected = !e.target.classList.contains(app.config.itemSelectClass);
	        if (notSelected) select(e.target);
	    }
	
	    function select(el) {
	        clean();
	        el.classList.add(app.config.itemSelectClass);
	        bodyClass(true);
	        app.emit('element:select', el);
	    }
	
	    function clean(el) {
	        if (!el) el = getSelected();
	        if (!el) return;
	        el.classList.remove(app.config.itemSelectClass);
	        bodyClass(false);
	        app.emit('element:unselect', el);
	    }
	
	    function getSelected() {
	        return app.svg.querySelector('.'+app.config.itemClass+'.'+app.config.itemSelectClass);
	    }
	
	    function bodyClass(active) {
	        document.body.classList[active ? 'add' : 'remove'](app.config.selectBodyClass);
	    }
	
	};


/***/ },
/* 10 */
/*!**********************!*\
  !*** ./core/move.js ***!
  \**********************/
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(/*! ./utils */ 6);
	
	module.exports = function(app) {
	
	
	    var animate = _.animation();
	
	    app.container.addEventListener(_.onDown(), drag);
	
	    function drag(e) {
	        var el = e.target;
	        var notElement = !el.classList.contains(app.config.itemClass);
	        if (notElement) return;
	
	        e.preventDefault(); // FF thing
	
	        var pos = calcOffset(e, el);
	
	        el.classList.add(app.config.itemDragClass);
	
	        app.svg.addEventListener(_.onMove(), updatePosition);
	        document.addEventListener(_.onUp(), drop);
	
	        function updatePosition(e) {
	            animate(function() {
	                _.translateSvg(el, _.pageX(e) - pos.x, _.pageY(e) - pos.y);
	                app.emit('move', el);
	            });
	        }
	
	        function drop(e) {
	            e.preventDefault(); // FF thing
	
	            app.svg.removeEventListener(_.onMove(), updatePosition);
	            document.removeEventListener(_.onUp(), drop);
	
	            el.classList.remove(app.config.itemDragClass);
	
	            app.emit('element:change:position', el);
	        }
	    }
	
	};
	
	
	function calcOffset(e, el) {
	    var pos = _.translateSvg(el);
	
	    return {
	        x: _.pageX(e) - pos.x,
	        y: _.pageY(e) - pos.y
	    };
	}


/***/ },
/* 11 */
/*!************************************!*\
  !*** ./plugins/utils/readImage.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var Promise = __webpack_require__(/*! promiscuous */ 13);
	var uriToPng = __webpack_require__(/*! ./uriToPng */ 12);
	
	
	module.exports = function(file) {
	
	    // TODO: warn if not image
	    if(!file.type.match(/image\/*/)) {
	        return Promise.reject();
	    }
	
	    return new Promise(function(resolve) {
	
	        var reader = new FileReader();
	
	        reader.onloadend = function() {
	            var blob = new Blob([this.result], { type: file.type });
	            var url = (window.URL || window.webkitURL || window).createObjectURL(blob);
	            resolve(uriToPng(url));
	        };
	
	        reader.readAsArrayBuffer(file);
	
	    });
	
	};


/***/ },
/* 12 */
/*!***********************************!*\
  !*** ./plugins/utils/uriToPng.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var Promise = __webpack_require__(/*! promiscuous */ 13);
	
	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	
	
	module.exports = function(url) {
	
	    return new Promise(function(resolve) {
	
	      var image = new Image();
	
	      image.onload = function() {
	          canvas.width = image.width;
	          canvas.height = image.height;
	          context.drawImage(image, 0, 0);
	          resolve({
	              url: canvas.toDataURL('image/png'),
	              width: image.width,
	              height: image.height
	          });
	      };
	
	      image.src = url;
	
	    });
	};


/***/ },
/* 13 */
/*!**************************************!*\
  !*** ./~/promiscuous/promiscuous.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/**@license MIT-promiscuous-©Ruben Verborgh*/
	(function (func, obj) {
	  // Type checking utility function
	  function is(type, item) { return (typeof item)[0] == type; }
	
	  // Creates a promise, calling callback(resolve, reject), ignoring other parameters.
	  function Promise(callback, handler) {
	    // The `handler` variable points to the function that will
	    // 1) handle a .then(resolved, rejected) call
	    // 2) handle a resolve or reject call (if the first argument === `is`)
	    // Before 2), `handler` holds a queue of callbacks.
	    // After 2), `handler` is a finalized .then handler.
	    handler = function pendingHandler(resolved, rejected, value, queue, then, i) {
	      queue = pendingHandler.q;
	
	      // Case 1) handle a .then(resolved, rejected) call
	      if (resolved != is) {
	        return Promise(function (resolve, reject) {
	          queue.push({ p: this, r: resolve, j: reject, 1: resolved, 0: rejected });
	        });
	      }
	
	      // Case 2) handle a resolve or reject call
	      // (`resolved` === `is` acts as a sentinel)
	      // The actual function signature is
	      // .re[ject|solve](<is>, success, value)
	
	      // Check if the value is a promise and try to obtain its `then` method
	      if (value && (is(func, value) | is(obj, value))) {
	        try { then = value.then; }
	        catch (reason) { rejected = 0; value = reason; }
	      }
	      // If the value is a promise, take over its state
	      if (is(func, then)) {
	        function valueHandler(resolved) {
	          return function (value) { then && (then = 0, pendingHandler(is, resolved, value)); };
	        }
	        try { then.call(value, valueHandler(1), rejected = valueHandler(0)); }
	        catch (reason) { rejected(reason); }
	      }
	      // The value is not a promise; handle resolve/reject
	      else {
	        // Replace this handler with a finalized resolved/rejected handler
	        handler = function (Resolved, Rejected) {
	          // If the Resolved or Rejected parameter is not a function,
	          // return the original promise (now stored in the `callback` variable)
	          if (!is(func, (Resolved = rejected ? Resolved : Rejected)))
	            return callback;
	          // Otherwise, return a finalized promise, transforming the value with the function
	          return Promise(function (resolve, reject) { finalize(this, resolve, reject, value, Resolved); });
	        };
	        // Resolve/reject pending callbacks
	        i = 0;
	        while (i < queue.length) {
	          then = queue[i++];
	          // If no callback, just resolve/reject the promise
	          if (!is(func, resolved = then[rejected]))
	            (rejected ? then.r : then.j)(value);
	          // Otherwise, resolve/reject the promise with the result of the callback
	          else
	            finalize(then.p, then.r, then.j, value, resolved);
	        }
	      }
	    };
	    // The queue of pending callbacks; garbage-collected when handler is resolved/rejected
	    handler.q = [];
	
	    // Create and return the promise (reusing the callback variable)
	    callback.call(callback = { then:  function (resolved, rejected) { return handler(resolved, rejected); },
	                               catch: function (rejected)           { return handler(0,        rejected); } },
	                  function (value)  { handler(is, 1,  value); },
	                  function (reason) { handler(is, 0, reason); });
	    return callback;
	  }
	
	  // Finalizes the promise by resolving/rejecting it with the transformed value
	  function finalize(promise, resolve, reject, value, transform) {
	    setImmediate(function () {
	      try {
	        // Transform the value through and check whether it's a promise
	        value = transform(value);
	        transform = value && (is(obj, value) | is(func, value)) && value.then;
	        // Return the result if it's not a promise
	        if (!is(func, transform))
	          resolve(value);
	        // If it's a promise, make sure it's not circular
	        else if (value == promise)
	          reject(TypeError());
	        // Take over the promise's state
	        else
	          transform.call(value, resolve, reject);
	      }
	      catch (error) { reject(error); }
	    });
	  }
	
	  // Export the main module
	  module.exports = Promise;
	
	  // Creates a resolved promise
	  Promise.resolve = ResolvedPromise;
	  function ResolvedPromise(value) { return Promise(function (resolve) { resolve(value); }); }
	
	  // Creates a rejected promise
	  Promise.reject = function (reason) { return Promise(function (resolve, reject) { reject(reason); }); };
	
	  // Transforms an array of promises into a promise for an array
	  Promise.all = function (promises) {
	    return Promise(function (resolve, reject, count, values) {
	      // Array of collected values
	      values = [];
	      // Resolve immediately if there are no promises
	      count = promises.length || resolve(values);
	      // Transform all elements (`map` is shorter than `forEach`)
	      promises.map(function (promise, index) {
	        ResolvedPromise(promise).then(
	          // Store the value and resolve if it was the last
	          function (value) {
	            values[index] = value;
	            --count || resolve(values);
	          },
	          // Reject if one element fails
	          reject);
	      });
	    });
	  };
	})('f', 'o');


/***/ },
/* 14 */
/*!******************************************!*\
  !*** ./plugins/backgroundColorPicker.js ***!
  \******************************************/
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(/*! ../core/utils */ 6);
	
	
	
	module.exports = function(app, options) {
	
	    options = _.defaults(options || {}, {
	        color: '#ffffff',
	        setButtonColor: true,
	        setTextColor: true
	    });
	
	    var background;
	
	    var container = document.querySelector(options.element);
	    var canvas = document.createElement('canvas');
	    var ctx = canvas.getContext('2d');
	
	    container.appendChild(canvas);
	
	    app.on('ready', ensureBackground);
	
	    container.addEventListener(_.onDown(), startTracking);
	
	
	    loadImage();
	
	
	
	    function ensureBackground() {
	        background = app.svg.querySelector('.background');
	        if (background) return;
	        background = _.createSvg('rect');
	        background.setAttribute('fill', options.color);
	        background.classList.add('background');
	        background.setAttribute('width', '100%');
	        background.setAttribute('height', '100%');
	        app.svg.insertBefore(background, app.svg.firstChild);
	    }
	
	
	    function loadImage() {
	        var image = new Image();
	        image.onload = function() {
	            canvas.width = image.width;
	            canvas.height = image.height;
	            ctx.drawImage(image, 0, 0, image.width, image.height);
	        };
	        image.src = options.image;
	    }
	
	
	    function startTracking(e) {
	        container.addEventListener(_.onMove(), updateBackgroundColor);
	        container.addEventListener(_.onUp(), stopTracking);
	
	        updateBackgroundColor(e);
	    }
	
	
	    function stopTracking() {
	        container.removeEventListener(_.onMove(), updateBackgroundColor);
	        container.removeEventListener(_.onUp(), stopTracking);
	
	        app.emit('background:update', background.fill);
	    }
	
	
	    function updateBackgroundColor(e) {
	        e.preventDefault(); // for touch events
	
	        var rect = e.target.getBoundingClientRect();
	        var left = _.pageX(e) - rect.left + document.body.scrollLeft;
	        var top =  _.pageY(e) - rect.top  + document.body.scrollTop;
	        var data = ctx.getImageData(left, top, 1, 1).data;
	        var color = 'rgb(' + data[0] + ',' + data[1] + ',' + data[2] + ')';
	
	        background.setAttribute('fill', color);
	    }
	
	
	};


/***/ }
/******/ ])
//# sourceMappingURL=graphicDesigner.min.js.map