/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/***/ function(module, exports, __webpack_require__) {

	// promisous dependency
	window.setImmediate = window.setTimeout;
	
	var graphicDesigner = __webpack_require__(/*! ./core */ 1);
	
	graphicDesigner.imageUpload = __webpack_require__(/*! ./plugins/imageUpload */ 2);
	
	
	window.graphicDesigner = graphicDesigner;


/***/ },
/* 1 */
/*!***********************!*\
  !*** ./core/index.js ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	var eventEmitter = __webpack_require__(/*! ./eventEmitter */ 3);
	var graphicElement = __webpack_require__(/*! ./graphicElement */ 4);
	var _ = __webpack_require__(/*! ./utils */ 5);
	
	
	var graphicDesigner = function(options) {
	
	    var app = {};
	
	    app.config = _.defaults(options || {}, defaults);
	
	    // plugin activation shortcuts
	    Object.keys(graphicDesigner).forEach(function(plugin) {
	        app[plugin] = function(options) {
	            graphicDesigner[plugin](app, options);
	        };
	    });
	
	
	    app.setSize = function(width, height) {
	        if (app.config.unit === 'mm') {
	            width  = mmToInch(width);
	            height = mmToInch(height);
	        }
	        if (app.config.unit !== 'pixel') {
	            width  = width  * app.config.dpi;
	            height = height * app.config.dpi;
	        }
	        app.svg.setAttribute('width' , Math.round(width  * app.config.scaleFactor));
	        app.svg.setAttribute('height', Math.round(height * app.config.scaleFactor));
	    };
	
	
	    app.eventEmitter();
	    app.graphicElement();
	
	
	    return app;
	};
	
	
	graphicDesigner.eventEmitter = eventEmitter;
	graphicDesigner.graphicElement = graphicElement;
	
	
	
	var defaults = {
	    unit: 'pixel',
	    dpi: 300,
	    width: 500,
	    height: 500,
	    scaleFactor: 1,
	    selectClass: 'item-selected',
	    itemClass: 'item',
	    itemSelectClass: 'selected',
	    itemDragClass: 'dragging'
	};
	
	
	
	var mmToInch = function(mm) {
	    return Math.round(mm * 3.937) / 100;
	};
	
	
	
	module.exports = graphicDesigner;


/***/ },
/* 2 */
/*!********************************!*\
  !*** ./plugins/imageUpload.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var readImage = __webpack_require__(/*! ./utils/readImage */ 6);
	var _ = __webpack_require__(/*! ../core/utils */ 5);
	
	
	module.exports = function(app, options) {
	
	    if (!options) options = {};
	
	    // chrome behaves weird and fires drag enter/leave events randomly
	    var throttle;
	
	    var input = document.createElement('input');
	    input.type = 'file';
	    input.accept = 'image/*';
	
	
	    function triggerFileInput() {
	        var event = document.createEvent('HTMLEvents');
	        event.initEvent('click', true, false);
	        input.dispatchEvent(event);
	    }
	    document.querySelector(options.element).addEventListener('click', triggerFileInput);
	
	    input.addEventListener('change', function() {
	        // TODO: warn on multiple files
	        if (input.files.length !== 1) return;
	        readImage(input.files[0]).then(scale).then(center).then(create);
	    });
	
	
	    function dragIn(e) {
	        e.preventDefault();
	        if (throttle) clearTimeout(throttle);
	        dropClass(true);
	    }
	    function dragOut() {
	        if (throttle) clearTimeout(throttle);
	        throttle = setTimeout(function() {
	            dropClass(false);
	        }, 300);
	    }
	    document.addEventListener('dragenter', dragIn);
	    document.addEventListener('dragover', dragIn);
	    document.addEventListener('dragleave', dragOut);
	
	    document.addEventListener('drop', function(e) {
	        e.preventDefault();
	        dropClass(false);
	        // TODO: warn on big image size
	        uploadDropped(e).then(scale).then(placeAt(e)).then(create);
	    });
	
	    function dropClass(active) {
	        if (options.dropBodyClass) {
	            document.body.classList[active ? 'add' : 'remove'](options.dropBodyClass);
	        }
	    }
	
	    function uploadDropped(e) {
	        // TODO: warn on multiple files and return rejected promise
	        if (e.dataTransfer.files.length > 1) return;
	
	        return readImage(e.dataTransfer.files[0]);
	    }
	
	    // scale to fit in screen
	    function scale(image) {
	        // NOTE: maybe there is a smarter way for this calcualtion ..
	        var rect = app.svg.getBoundingClientRect();
	        var factor = Math.min(rect.width / image.width, rect.height / image.height, 1);
	        image.width = Math.round(factor * image.width);
	        image.height = Math.round(factor * image.height);
	        return image;
	    }
	
	    function center(image) {
	        var rect = app.svg.getBoundingClientRect();
	        image.x = Math.round(0.5 * (rect.width - image.width ));
	        image.y = Math.round(0.5 * (rect.height - image.height ));
	        return image;
	    }
	
	    function create(image) {
	        var el = _.createSvg('image');
	        el.setAttribute('height', image.height);
	        el.setAttribute('width', image.width);
	        el.setAttribute('class', 'element');
	        el.setAttributeNS('http://www.w3.org/1999/xlink','href', image.url);
	
	        _.translateSvg(el, image.x, image.y);
	
	        app.svg.appendChild(el);
	        app.emit('create:element', el);
	    }
	
	    function placeAt(event) {
	        if (event.target !== app.svg) {
	            return center;
	        }
	        return function(image) {
	            var rect = app.svg.getBoundingClientRect();
	            var top  = rect.top  + document.body.scrollTop;
	            var left = rect.left + document.body.scrollLeft;
	
	            image.x = Math.round(event.pageX - left - 0.5 * image.width);
	            image.y = Math.round(event.pageY - top  - 0.5 * image.height);
	
	            return image;
	        };
	    }
	
	    return app;
	};


/***/ },
/* 3 */
/*!******************************!*\
  !*** ./core/eventEmitter.js ***!
  \******************************/
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(obj) {
	
	    var events = {};
	    var slice = [].slice;
	
	
	    // Infinite handlers support:
	    // obj.on = function(event) {
	    //     var handlers = slice.call(arguments, 1);
	    //     for (var i = 0, handler; (handler = handlers[i]); ++i) {
	    //         (events[event] = events[event] || []).push(handler);
	    //     }
	    //     return obj;
	    // };
	
	    obj.on = function(event, handler) {
	        (events[event] = events[event] || []).push(handler);
	        return obj;
	    };
	
	
	    obj.once = function(event, handler) {
	        return obj.on(event, function onceWrapper() {
	            handler.apply(null, arguments);
	            obj.off(event, onceWrapper);
	        });
	    };
	
	
	    obj.emit = function(event) {
	        var i, handler;
	        var args = slice.call(arguments, 1);
	        var handlers = [];
	
	        // emit sub:events
	        var parts = event.split(':');
	        for (i = 1; i <= parts.length; i++) {
	            var subHandlers = events[parts.slice(0, i).join(':')];
	            if (subHandlers) handlers = handlers.concat(subHandlers);
	        }
	
	        // NOTE: doesn't log names for once listeners
	        // DEBUG
	        console.log('EVENT: ', event, ' => ',
	            handlers.map(function(f) {
	                return f.name;
	            }).join(', ') || 'nothing to do ...'
	        );
	
	        for (i = 0, handler; (handler = handlers[i]); ++i) {
	            handler.apply(null, args);
	        }
	
	        return obj;
	    };
	
	
	    // remove specific handler or remove all handlers
	    obj.off = function(event, handler) {
	        if (handler) {
	            var handlers = events[event];
	            var i = handlers.indexOf(handler);
	            if (i >= 0) handlers.splice(i, 1);
	        } else {
	            events[event] = [];
	        }
	
	        return obj;
	    };
	
	
	    // obj.stop = function(event, handler) {
	
	    //     if (event === "*") {
	    //         events = {};
	    //     } else if (handler) {
	    //         var arr = events[event];
	    //         for (var i = 0, cb; (cb = arr && arr[i]); ++i) {
	    //             if (cb === handler) {
	    //                 arr.splice(i, 1); i--;
	    //             }
	    //         }
	    //     } else {
	    //         event.replace(/\S+/g, function(name) {
	    //             events[name] = [];
	    //         });
	    //     }
	    //     return obj;
	    // };
	
	
	
	    return obj;
	};


/***/ },
/* 4 */
/*!********************************!*\
  !*** ./core/graphicElement.js ***!
  \********************************/
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(/*! ./utils */ 5);
	
	module.exports = function(app) {
	
	    var container = document.querySelector(app.config.element);
	
	    var svg = _.createSvg('svg');
	
	    container.innerHTML = ''; // empty first
	    container.appendChild(svg);
	
	    app.svg = svg;
	
	    app.setSize(app.config.width, app.config.height);
	
	    app.emit('svg:loaded');
	
	};


/***/ },
/* 5 */
/*!***********************!*\
  !*** ./core/utils.js ***!
  \***********************/
/***/ function(module, exports, __webpack_require__) {

	// TODO: stolen from lodash
	
	var utils = {};
	
	/** Used to determine if values are of the language type Object */
	var objectTypes = {
	    'boolean': false,
	    'function': true,
	    'object': true,
	    'number': false,
	    'string': false,
	    'undefined': false
	};
	
	/**
	 * Assigns own enumerable properties of source object(s) to the destination
	 * object for all destination properties that resolve to `undefined`. Once a
	 * property is set, additional defaults of the same property will be ignored.
	 *
	 * @static
	 * @memberOf _
	 * @type Function
	 * @category Objects
	 * @param {Object} object The destination object.
	 * @param {...Object} [source] The source objects.
	 * @param- {Object} [guard] Allows working with `_.reduce` without using its
	 *  `key` and `object` arguments as sources.
	 * @returns {Object} Returns the destination object.
	 * @example
	 *
	 * var object = { 'name': 'barney' };
	 * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
	 * // => { 'name': 'barney', 'employer': 'slate' }
	 */
	utils.defaults = function(object, source, guard) {
	  var index, iterable = object, result = iterable;
	  if (!iterable) return result;
	  var args = arguments,
	      argsIndex = 0,
	      argsLength = typeof guard == 'number' ? 2 : args.length;
	  while (++argsIndex < argsLength) {
	    iterable = args[argsIndex];
	    if (iterable && objectTypes[typeof iterable]) {
	    var ownIndex = -1,
	        ownProps = objectTypes[typeof iterable] && Object.keys(iterable),
	        length = ownProps ? ownProps.length : 0;
	
	    while (++ownIndex < length) {
	      index = ownProps[ownIndex];
	      if (typeof result[index] == 'undefined') result[index] = iterable[index];
	    }
	    }
	  }
	  return result;
	};
	
	
	
	utils.createSvg = function(tag) {
	    return document.createElementNS('http://www.w3.org/2000/svg', tag);
	};
	
	
	
	utils.translateSvg = function(el) {
	    var values = Array.prototype.slice.call(arguments, 1);
	    if (values.length) return setProp(el, 'translate', values);
	
	    var prop = getProp(el, 'translate');
	    if (!prop) return { x: 0, y: 0 };
	    return { x: prop[0], y: prop[prop.length-1] };
	};
	
	
	function setProp(el, prop, values) {
	    var old = el.getAttribute('transform');
	    var attr;
	    if (!old) {
	        attr = propStr(prop, values);
	    } else if (!old.match(prop)) {
	        attr = old + ' ' + propStr(prop, values);
	    } else {
	        attr = old.replace( new RegExp(prop+'\\((.+?)\\)'), propStr(prop, values) );
	    }
	    return el.setAttribute('transform', attr);
	}
	
	function getProp(el, prop) {
	    var attr = el.getAttribute('transform');
	    if (!attr) return;
	    var raw = attr.match(prop + '\\((.+?)\\)');
	    if (!raw) return;
	    return raw[1].trim().split(' ').map(function(val) {
	        return parseInt(val, 10);
	    });
	}
	
	
	function propStr(prop, values) {
	    return prop+'('+values.join(' ')+')';
	}
	
	module.exports = utils;


/***/ },
/* 6 */
/*!************************************!*\
  !*** ./plugins/utils/readImage.js ***!
  \************************************/
/***/ function(module, exports, __webpack_require__) {

	var Promise = __webpack_require__(/*! promiscuous */ 8);
	var uriToPng = __webpack_require__(/*! ./uriToPng */ 7);
	
	
	module.exports = function(file) {
	
	    // TODO: warn if not image
	    if(!file.type.match(/image\/*/)) {
	        return Promise.reject();
	    }
	
	    return new Promise(function(resolve) {
	
	        var reader = new FileReader();
	
	        reader.onloadend = function() {
	            var blob = new Blob([this.result], { type: file.type });
	            var url = (window.URL || window.webkitURL || window).createObjectURL(blob);
	            resolve(uriToPng(url));
	        };
	
	        reader.readAsArrayBuffer(file);
	
	    });
	
	};


/***/ },
/* 7 */
/*!***********************************!*\
  !*** ./plugins/utils/uriToPng.js ***!
  \***********************************/
/***/ function(module, exports, __webpack_require__) {

	var Promise = __webpack_require__(/*! promiscuous */ 8);
	
	var canvas = document.createElement('canvas');
	var context = canvas.getContext('2d');
	
	
	module.exports = function(url) {
	
	    return new Promise(function(resolve) {
	
	      var image = new Image();
	
	      image.onload = function() {
	          canvas.width = image.width;
	          canvas.height = image.height;
	          context.drawImage(image, 0, 0);
	          resolve({
	              url: canvas.toDataURL('image/png'),
	              width: image.width,
	              height: image.height
	          });
	      };
	
	      image.src = url;
	
	    });
	};


/***/ },
/* 8 */
/*!**************************************!*\
  !*** ./~/promiscuous/promiscuous.js ***!
  \**************************************/
/***/ function(module, exports, __webpack_require__) {

	/**@license MIT-promiscuous-©Ruben Verborgh*/
	(function (func, obj) {
	  // Type checking utility function
	  function is(type, item) { return (typeof item)[0] == type; }
	
	  // Creates a promise, calling callback(resolve, reject), ignoring other parameters.
	  function Promise(callback, handler) {
	    // The `handler` variable points to the function that will
	    // 1) handle a .then(resolved, rejected) call
	    // 2) handle a resolve or reject call (if the first argument === `is`)
	    // Before 2), `handler` holds a queue of callbacks.
	    // After 2), `handler` is a finalized .then handler.
	    handler = function pendingHandler(resolved, rejected, value, queue, then, i) {
	      queue = pendingHandler.q;
	
	      // Case 1) handle a .then(resolved, rejected) call
	      if (resolved != is) {
	        return Promise(function (resolve, reject) {
	          queue.push({ p: this, r: resolve, j: reject, 1: resolved, 0: rejected });
	        });
	      }
	
	      // Case 2) handle a resolve or reject call
	      // (`resolved` === `is` acts as a sentinel)
	      // The actual function signature is
	      // .re[ject|solve](<is>, success, value)
	
	      // Check if the value is a promise and try to obtain its `then` method
	      if (value && (is(func, value) | is(obj, value))) {
	        try { then = value.then; }
	        catch (reason) { rejected = 0; value = reason; }
	      }
	      // If the value is a promise, take over its state
	      if (is(func, then)) {
	        function valueHandler(resolved) {
	          return function (value) { then && (then = 0, pendingHandler(is, resolved, value)); };
	        }
	        try { then.call(value, valueHandler(1), rejected = valueHandler(0)); }
	        catch (reason) { rejected(reason); }
	      }
	      // The value is not a promise; handle resolve/reject
	      else {
	        // Replace this handler with a finalized resolved/rejected handler
	        handler = function (Resolved, Rejected) {
	          // If the Resolved or Rejected parameter is not a function,
	          // return the original promise (now stored in the `callback` variable)
	          if (!is(func, (Resolved = rejected ? Resolved : Rejected)))
	            return callback;
	          // Otherwise, return a finalized promise, transforming the value with the function
	          return Promise(function (resolve, reject) { finalize(this, resolve, reject, value, Resolved); });
	        };
	        // Resolve/reject pending callbacks
	        i = 0;
	        while (i < queue.length) {
	          then = queue[i++];
	          // If no callback, just resolve/reject the promise
	          if (!is(func, resolved = then[rejected]))
	            (rejected ? then.r : then.j)(value);
	          // Otherwise, resolve/reject the promise with the result of the callback
	          else
	            finalize(then.p, then.r, then.j, value, resolved);
	        }
	      }
	    };
	    // The queue of pending callbacks; garbage-collected when handler is resolved/rejected
	    handler.q = [];
	
	    // Create and return the promise (reusing the callback variable)
	    callback.call(callback = { then:  function (resolved, rejected) { return handler(resolved, rejected); },
	                               catch: function (rejected)           { return handler(0,        rejected); } },
	                  function (value)  { handler(is, 1,  value); },
	                  function (reason) { handler(is, 0, reason); });
	    return callback;
	  }
	
	  // Finalizes the promise by resolving/rejecting it with the transformed value
	  function finalize(promise, resolve, reject, value, transform) {
	    setImmediate(function () {
	      try {
	        // Transform the value through and check whether it's a promise
	        value = transform(value);
	        transform = value && (is(obj, value) | is(func, value)) && value.then;
	        // Return the result if it's not a promise
	        if (!is(func, transform))
	          resolve(value);
	        // If it's a promise, make sure it's not circular
	        else if (value == promise)
	          reject(TypeError());
	        // Take over the promise's state
	        else
	          transform.call(value, resolve, reject);
	      }
	      catch (error) { reject(error); }
	    });
	  }
	
	  // Export the main module
	  module.exports = Promise;
	
	  // Creates a resolved promise
	  Promise.resolve = ResolvedPromise;
	  function ResolvedPromise(value) { return Promise(function (resolve) { resolve(value); }); }
	
	  // Creates a rejected promise
	  Promise.reject = function (reason) { return Promise(function (resolve, reject) { reject(reason); }); };
	
	  // Transforms an array of promises into a promise for an array
	  Promise.all = function (promises) {
	    return Promise(function (resolve, reject, count, values) {
	      // Array of collected values
	      values = [];
	      // Resolve immediately if there are no promises
	      count = promises.length || resolve(values);
	      // Transform all elements (`map` is shorter than `forEach`)
	      promises.map(function (promise, index) {
	        ResolvedPromise(promise).then(
	          // Store the value and resolve if it was the last
	          function (value) {
	            values[index] = value;
	            --count || resolve(values);
	          },
	          // Reject if one element fails
	          reject);
	      });
	    });
	  };
	})('f', 'o');


/***/ }
/******/ ])
//# sourceMappingURL=graphicDesigner.min.js.map